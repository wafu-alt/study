### **타입스크립트 기본**
참조 : https://joshua1988.github.io/ts/why-ts.html   
출처 : 엘리스 SW엔지니어 트랙

## Typscirpt?

타입스크립트는 자바스크립트에 타입을 부여한 언어입니다. 자바스크립트의 확장된 언어라고 볼 수 있습니다. 타입스크립트는 자바스크립트와 달리 브라우저에서 실행하려면 파일을 한번 변환해주어야 합니다. 이 변환 과정을 우리는 컴파일(complile) 이라고 부릅니다
## 써야하는 이유?
- 에러의 사전 방지
## 기본 타입
타입스크립트에서 기본으로 제공하는 타입들입니다.**기본 자료형**

- **`string`**: 문자열
- **`Boolean`** : 참 / 거짓
- **`number`** : 숫자
- **`null`** : 의도적으로 비어있는 값
- **`undefined`** : 아무 값이 할당되지 않은 상태

**참조 자료형**

- **`object`** : 기본 자료형 외의 타입
- **`array`** : 배열

**추가 자료형***

- **`tuple`** : 길이와 각 요소의 타입이 정해진 배열
- **`enum`** : 특정 값들의 집합
- **`any`** : 모든 타입을 저장 가능
- **`void`** : 결과 값을 반환하지 않는 함수의 타입
- **`never`** : 항상 오류를 발생시키거나 반환이 없는 함수의 타입

### **Utility types**

유틸리티 타입에 앞서 먼저 타입을 직접 정의하는 방법(type alias)을 알아보겠습니다.

```
let p1: {name:string, age:number} = {
  name: "elice",
  age: 13
};

```

위와 같이 타입을 직접 정의할 수 있지만, 매번 타입을 정의하는 것은 불편하기 때문에 아래와 같이 타입 자체에 이름을 붙어 변수를 만들 수 있습니다.

```
type Human = {
  name: string;
  age: number;
};

let p2:Human = {name: "cheshire", age:15};

```

여기서 `name`과 `age`를 프로퍼티라고 합니다. 이러한 타입은 뒤에서 배울 인터페이스와 유사한데, 뒤에서 더 자세히 학습할 예정입니다.

그래서 유틸리티 타입이란 이미 정의해 놓은 타입을 변환하고 싶을 때 사용하면 좋은 타입입니다. 유틸리티 타입을 이용하면 기존의 타입을 이용해 새로운 타입을 만들 수 있습니다. (마찬가지로 인터페이스에도 유틸리티 타입을 적용할 수 있습니다.)

유틸리티 타입에서 사용되는 `<T>`와 같은 꺾쇠 형태는 뒤에서 배울 제네릭(Generic)의 문법입니다. 제네릭이란 어떤 함수나 클래스가 사용할 타입을 생성 단계가 아닌 사용 단계에서 정의하는 프로그래밍 기법입니다. 제너릭은 뒤에서 더 자세히 다룰 예정입니다. 이번 장에서는 제네릭을 이용해 정의된 타입을 쉽게 변경할 수 있도록 도와주는 유틸리티 타입들에 무엇이 있는지를 학습해보시기를 바랍니다. (강의자료에 있는 코드를 한 번씩 실행해보면서 익히기를 권장합니다.)
- **`Partial<T>`** : T의 프로퍼티를 선택적으로 구성할 수 있습니다.
- **`Readonly<T>`** : T의 프로퍼티를 읽기 전용으로 설정하여, 값을 재할당하는 경우 에러가 발생합니다.
- **`Record<T, K>`** : 프로퍼티 키를 K, 값을 T로 하는 타입을 만들 수 있습니다.
    - 여러 키들을 지정하기 위해 타입을 선언한 방식(**`type Page = 'home' | 'about' | 'contact';`**)처럼 두 개 이상의 타입을 선언하는 방식을 유니온 타입이라고 합니다.
- **`Pick<T, K>`** : T 타입 중에서 K 프로퍼티만 지정하여 타입을 만들 수 있습니다.
- **`Omit<T, K>`** : T 타입의 모든 프로퍼티 중 K를 제거하여 타입을 구성합니다.
- **`Exclude<T, U>`** : 타입 T에서 U와 겹치는 타입을 제외한 타입을 구성합니다.
- **`Extract<T, U>`** : 타입 T에서 U와 겹치는 타입만 포함하여 타입을 구성합니다.
- **`NonNllable<T>`** : T 타입에서 null과 undefined를 제외한 타입을 구성합니다.
- **`Parameter<T>`** : 함수 타입 T의 매개변수의 타입들의 튜플로 타입을 구성합니다.
- **`ConstructorParameters<T>`** : 클래스의 생성자를 비롯한 생성자 타입의 모든 매개변수 타입을 추출합니다.
- **`ReturnType<T>`** : 함수 T가 반환한 타입으로 타입을 구성합니다.
- **`Required<T>`** : 타입 T의 모든 프로퍼티가 필수로 설정된 타입을 구성합니다.

### **TypeScript를 이용해 함수 사용하기**

**매개변수와 인수**

```
function add(x, y) {
    return x + y;
}
add(2, 5);

```

- 매개변수 : 함수를 정의할 때 사용되는 변수를 매개변수라고 합니다. (**`x`**, **`y`**)
- 인수 : 함수를 호출할 때 사용되는 값을 인수라고 합니다. (**`2`**, **`5`**)
- 인자 값, 매개변수, 파라미터(Parameter)는 모두 같은 말입니다.
      
**일급 객체**

- 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 일급 객체라고 합니다.
- 자바스크립트의 함수는 다른 함수에 매개변수로 제공할 수 있습니다.

```
let elice = function(func) {
   func();
}

elice(function() {
   console.log('coding');// "coding"
});

```

- 자바스크립트의 함수는 함수에서 반환이 가능합니다.

```
function elice() {
   return function() {
       console.log('coding');// "coding"
   }
}

let test = elice();
test();

```

- 자바스크립트의 함수는 변수에 할당이 가능합니다.

```
let elice = function() { return "coding"; };
console.log(elice());// "coding"
```

- 따라서 자바스크립트의 함수는 일급 객체이고, 타입스크립트도 동일합니다. 이러한 타입스크립트 함수의 특성 때문에 함수를 선언하는 5가지 방식이 있습니다.
    - 선언 방법 함수 선언식, 함수 표현식, 화살표 함수 표현식, 단축형 화살표 함수 표현식, 함수 생성자 → 각 함수 선언 방식의 차이를 알고 사용하시기를 바랍니다.
    - 함수 선언식은 [호이스팅](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)이 되지만, 함수 표현식은 호이스팅이 되지 않습니다.
    - 일반 함수는 함수가 호출될 때 this에 바인딩할 객체가 동적으로 정해지지만, 화살표 함수는 함수를 선언할 때 정적으로 정해집니다.




**타입스크립트와 함수**

- 타입스크립트에서 함수를 사용할 때는 매개변수에 타입을 지정하여 올바른 인수가 전달되도록 합니다.
- 타입스크립트는 타입 추론이 가능하기 때문에, 함수 사용 시 모든 타입을 일일이 명시하지 않아도 되는 경우도 있습니다.

```
function add(a: number, b: number) {
    const res = a + b;
    return res.toString();
}

```

- 위의 경우 **`res`** 변수는 number, 반환 값은 string이라는 것이 명백하기 때문에 따로 타입을 명시하지 않아도 됩니다. 이는 코드가 짧아지는 이점이 있습니다.



    
### **객체 지향 프로그래밍(OOP)**

OOP란 Object-oriented programming의 준말로 컴퓨터 프로그램을 객체의 모임으로 파악하려는 프로그래밍 패러다임입니다. 프로그래밍을 객체 단위로 나눠서 작성하는 것으로, 예를 들어 사람을 하나의 객체라고 한다면 사람을 구성하는 뇌부터 눈, 코, 입, 귀, 팔, 다리 등을 각각 나눠서 관리하고 서로 상호작용하여 결국 사람이 밥을 먹거나, 코딩을 하는 등의 동작을 하도록 만드는 것입니다.

이렇게 OOP를 적용하면 프로그램을 변경하고 싶거나, 오류를 해결할 때 모든 구조를 뜯어 고치지 않고 문제가 되는 객체만 들여다 보면 됩니다. 즉 프로그램이 유연하고 변경이 용이하며, 개발과 보수가 간편한 이점이 있습니다. 잘 나누어진 객체는 직관적인 코드 분석을 가능하게 합니다.

객체 지향의 중요한 프로그래밍 특성은 **강한 응집력과 약한 결합력**입니다. **응집력**이란 프로그램의 한 요소가 여러 기능에 얼마만큼 책임을 지고 있는지 나타내는 것으로, 응집력이 높으면 하나의 요소가 하나의 기능을 관여하기 때문에 요소의 목표가 뚜렷하지만 응집력이 낮으면 하나의 요소가 여러 기능을 관여하는 것으로 코드를 이해하기 어렵게 됩니다. **결합력**이란 프로그램이 기능을 수행하는 데 있어 여러 요소가 얼마만큼 연관이 되어 있는지 나타내는 것으로, 결합력이 낮으면 각 요소를 독립적으로 관리하기 용이하지만 결합력이 높으면 하나의 요소를 수정하기 위해 여러 요소를 모두 확인해야 합니다.

지금까시 설명한 객체를 클래스에 빗대어 다시 표현하자면 사람 **클래스**에서 **필드(Field)** 는 눈, 코, 입과 같은 신체 기관이 되는 것이고, **메소드(Method)** 는 행동이 되는 것입니다. 그리고 사람이 만들어질 때 초기값을 넣기 위한 호출되는 것을 **생성자(Constructor)** 라고 하며 필드, 메소드, 생성자를 클래스의 **멤버(Member)** 라고 부릅니다. **인스턴스(Instance)** 는 만들어진 각각의 사람을 나타냅니다.

**클래스 문법**

- **`class`** 키워드를 이용해 클래스를 만들 수 있습니다.
- 클래스 내에서 클래스 멤버를 사용하기 위해서는 **`this`** 키워드를 사용합니다.
- **`new`** 키워드를 이용해 클래스의 인스턴스를 생성합니다.

