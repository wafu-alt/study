### **타입스크립트 기본**
참조 : https://joshua1988.github.io/ts/why-ts.html   
출처 : 엘리스 SW엔지니어 트랙

## Typscirpt?

타입스크립트는 자바스크립트에 타입을 부여한 언어입니다. 자바스크립트의 확장된 언어라고 볼 수 있습니다. 타입스크립트는 자바스크립트와 달리 브라우저에서 실행하려면 파일을 한번 변환해주어야 합니다. 이 변환 과정을 우리는 컴파일(complile) 이라고 부릅니다
## 써야하는 이유?
- 에러의 사전 방지
## 기본 타입
타입스크립트에서 기본으로 제공하는 타입들입니다.**기본 자료형**

- **`string`**: 문자열
- **`Boolean`** : 참 / 거짓
- **`number`** : 숫자
- **`null`** : 의도적으로 비어있는 값
- **`undefined`** : 아무 값이 할당되지 않은 상태

**참조 자료형**

- **`object`** : 기본 자료형 외의 타입
- **`array`** : 배열

**추가 자료형***

- **`tuple`** : 길이와 각 요소의 타입이 정해진 배열
- **`enum`** : 특정 값들의 집합
- **`any`** : 모든 타입을 저장 가능
- **`void`** : 결과 값을 반환하지 않는 함수의 타입
- **`never`** : 항상 오류를 발생시키거나 반환이 없는 함수의 타입

### **Utility types**

유틸리티 타입에 앞서 먼저 타입을 직접 정의하는 방법(type alias)을 알아보겠습니다.

```
let p1: {name:string, age:number} = {
  name: "elice",
  age: 13
};

```

위와 같이 타입을 직접 정의할 수 있지만, 매번 타입을 정의하는 것은 불편하기 때문에 아래와 같이 타입 자체에 이름을 붙어 변수를 만들 수 있습니다.

```
type Human = {
  name: string;
  age: number;
};

let p2:Human = {name: "cheshire", age:15};

```

여기서 `name`과 `age`를 프로퍼티라고 합니다. 이러한 타입은 뒤에서 배울 인터페이스와 유사한데, 뒤에서 더 자세히 학습할 예정입니다.

그래서 유틸리티 타입이란 이미 정의해 놓은 타입을 변환하고 싶을 때 사용하면 좋은 타입입니다. 유틸리티 타입을 이용하면 기존의 타입을 이용해 새로운 타입을 만들 수 있습니다. (마찬가지로 인터페이스에도 유틸리티 타입을 적용할 수 있습니다.)

유틸리티 타입에서 사용되는 `<T>`와 같은 꺾쇠 형태는 뒤에서 배울 제네릭(Generic)의 문법입니다. 제네릭이란 어떤 함수나 클래스가 사용할 타입을 생성 단계가 아닌 사용 단계에서 정의하는 프로그래밍 기법입니다. 제너릭은 뒤에서 더 자세히 다룰 예정입니다. 이번 장에서는 제네릭을 이용해 정의된 타입을 쉽게 변경할 수 있도록 도와주는 유틸리티 타입들에 무엇이 있는지를 학습해보시기를 바랍니다. (강의자료에 있는 코드를 한 번씩 실행해보면서 익히기를 권장합니다.)
- **`Partial<T>`** : T의 프로퍼티를 선택적으로 구성할 수 있습니다.
- **`Readonly<T>`** : T의 프로퍼티를 읽기 전용으로 설정하여, 값을 재할당하는 경우 에러가 발생합니다.
- **`Record<T, K>`** : 프로퍼티 키를 K, 값을 T로 하는 타입을 만들 수 있습니다.
    - 여러 키들을 지정하기 위해 타입을 선언한 방식(**`type Page = 'home' | 'about' | 'contact';`**)처럼 두 개 이상의 타입을 선언하는 방식을 유니온 타입이라고 합니다.
- **`Pick<T, K>`** : T 타입 중에서 K 프로퍼티만 지정하여 타입을 만들 수 있습니다.
- **`Omit<T, K>`** : T 타입의 모든 프로퍼티 중 K를 제거하여 타입을 구성합니다.
- **`Exclude<T, U>`** : 타입 T에서 U와 겹치는 타입을 제외한 타입을 구성합니다.
- **`Extract<T, U>`** : 타입 T에서 U와 겹치는 타입만 포함하여 타입을 구성합니다.
- **`NonNllable<T>`** : T 타입에서 null과 undefined를 제외한 타입을 구성합니다.
- **`Parameter<T>`** : 함수 타입 T의 매개변수의 타입들의 튜플로 타입을 구성합니다.
- **`ConstructorParameters<T>`** : 클래스의 생성자를 비롯한 생성자 타입의 모든 매개변수 타입을 추출합니다.
- **`ReturnType<T>`** : 함수 T가 반환한 타입으로 타입을 구성합니다.
- **`Required<T>`** : 타입 T의 모든 프로퍼티가 필수로 설정된 타입을 구성합니다.

### **TypeScript를 이용해 함수 사용하기**

**매개변수와 인수**

```
function add(x, y) {
    return x + y;
}
add(2, 5);

```

- 매개변수 : 함수를 정의할 때 사용되는 변수를 매개변수라고 합니다. (**`x`**, **`y`**)
- 인수 : 함수를 호출할 때 사용되는 값을 인수라고 합니다. (**`2`**, **`5`**)
- 인자 값, 매개변수, 파라미터(Parameter)는 모두 같은 말입니다.
      
**일급 객체**

- 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 일급 객체라고 합니다.
- 자바스크립트의 함수는 다른 함수에 매개변수로 제공할 수 있습니다.

```
let elice = function(func) {
   func();
}

elice(function() {
   console.log('coding');// "coding"
});

```

- 자바스크립트의 함수는 함수에서 반환이 가능합니다.

```
function elice() {
   return function() {
       console.log('coding');// "coding"
   }
}

let test = elice();
test();

```

- 자바스크립트의 함수는 변수에 할당이 가능합니다.

```
let elice = function() { return "coding"; };
console.log(elice());// "coding"
```

- 따라서 자바스크립트의 함수는 일급 객체이고, 타입스크립트도 동일합니다. 이러한 타입스크립트 함수의 특성 때문에 함수를 선언하는 5가지 방식이 있습니다.
    - 선언 방법 함수 선언식, 함수 표현식, 화살표 함수 표현식, 단축형 화살표 함수 표현식, 함수 생성자 → 각 함수 선언 방식의 차이를 알고 사용하시기를 바랍니다.
    - 함수 선언식은 [호이스팅](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)이 되지만, 함수 표현식은 호이스팅이 되지 않습니다.
    - 일반 함수는 함수가 호출될 때 this에 바인딩할 객체가 동적으로 정해지지만, 화살표 함수는 함수를 선언할 때 정적으로 정해집니다.




**타입스크립트와 함수**

- 타입스크립트에서 함수를 사용할 때는 매개변수에 타입을 지정하여 올바른 인수가 전달되도록 합니다.
- 타입스크립트는 타입 추론이 가능하기 때문에, 함수 사용 시 모든 타입을 일일이 명시하지 않아도 되는 경우도 있습니다.

```
function add(a: number, b: number) {
    const res = a + b;
    return res.toString();
}

```

- 위의 경우 **`res`** 변수는 number, 반환 값은 string이라는 것이 명백하기 때문에 따로 타입을 명시하지 않아도 됩니다. 이는 코드가 짧아지는 이점이 있습니다.



    
### **객체 지향 프로그래밍(OOP)**

OOP란 Object-oriented programming의 준말로 컴퓨터 프로그램을 객체의 모임으로 파악하려는 프로그래밍 패러다임입니다. 프로그래밍을 객체 단위로 나눠서 작성하는 것으로, 예를 들어 사람을 하나의 객체라고 한다면 사람을 구성하는 뇌부터 눈, 코, 입, 귀, 팔, 다리 등을 각각 나눠서 관리하고 서로 상호작용하여 결국 사람이 밥을 먹거나, 코딩을 하는 등의 동작을 하도록 만드는 것입니다.

이렇게 OOP를 적용하면 프로그램을 변경하고 싶거나, 오류를 해결할 때 모든 구조를 뜯어 고치지 않고 문제가 되는 객체만 들여다 보면 됩니다. 즉 프로그램이 유연하고 변경이 용이하며, 개발과 보수가 간편한 이점이 있습니다. 잘 나누어진 객체는 직관적인 코드 분석을 가능하게 합니다.

객체 지향의 중요한 프로그래밍 특성은 **강한 응집력과 약한 결합력**입니다. **응집력**이란 프로그램의 한 요소가 여러 기능에 얼마만큼 책임을 지고 있는지 나타내는 것으로, 응집력이 높으면 하나의 요소가 하나의 기능을 관여하기 때문에 요소의 목표가 뚜렷하지만 응집력이 낮으면 하나의 요소가 여러 기능을 관여하는 것으로 코드를 이해하기 어렵게 됩니다. **결합력**이란 프로그램이 기능을 수행하는 데 있어 여러 요소가 얼마만큼 연관이 되어 있는지 나타내는 것으로, 결합력이 낮으면 각 요소를 독립적으로 관리하기 용이하지만 결합력이 높으면 하나의 요소를 수정하기 위해 여러 요소를 모두 확인해야 합니다.

지금까시 설명한 객체를 클래스에 빗대어 다시 표현하자면 사람 **클래스**에서 **필드(Field)** 는 눈, 코, 입과 같은 신체 기관이 되는 것이고, **메소드(Method)** 는 행동이 되는 것입니다. 그리고 사람이 만들어질 때 초기값을 넣기 위한 호출되는 것을 **생성자(Constructor)** 라고 하며 필드, 메소드, 생성자를 클래스의 **멤버(Member)** 라고 부릅니다. **인스턴스(Instance)** 는 만들어진 각각의 사람을 나타냅니다.

**클래스 문법**

- **`class`** 키워드를 이용해 클래스를 만들 수 있습니다.
- 클래스 내에서 클래스 멤버를 사용하기 위해서는 **`this`** 키워드를 사용합니다.
- **`new`** 키워드를 이용해 클래스의 인스턴스를 생성합니다.

   
### **접근 제어자 / 상속**

**접근 제어자**접근 제어자는 속성 또는 메소드로의 접근을 제어하기 위해 사용됩니다. 타입스크립트에는 3가지 접근 제어자가 존재합니다.

- **`public`**
    - 선언된 멤버를 클래스 밖에서도 자유롭게 접근할 수 있습니다.
    - 타입스크립트의 멤버는 기본적으로 **`public`**으로 선언되지만, 명시적으로 표시해도 됩니다.
- **`protected`**
    - 멤버가 포함된 클래스와 그 하위 클래스에서만 접근할 수 있습니다.
- **`priavte`**
    - 선언된 멤버를 클래스 외부에서 접근할 수 없습니다.

**상속**OOP는 상속을 이용해 존재하는 클래스를 확장해 새로운 클래스를 생성할 수 있습니다. 예를 들어 사람 클래스를 확장하여 아이, 어른, 노인과 같은 새로운 클래스를 만들 수 있습니다.

**`extends`** 키워드를 이용해 클래스를 상속하며 파생된 클래스를 하위 클래스(subclass), 기초 클래스를 상위 클래스(superclass)라고 부릅니다.

하위 클래스는 상위 클래스의 기능(메소드)을 확장합니다. 예를 들어 사람 클래스에 움직이는 기능이 있었다면, 어른과 노인 모두 똑같이 움직이는 기능을 확장하여 사용합니다. 다만, 둘의 움직이는 속도를 다르게 하는 등 세부적으로 변경하여 사용합니다.

### Getters & Setters / readonly / static

**getters & setters**비공개로 설정하려는 속성은 private로 설정하여 직접 호출하거나 수정하지 않습니다. 대신 getter / setter 함수를 사용합니다.

클래스의 멤버에 잘못된 값을 넣어 에러를 발생시키는 것을 막기 위해 이용합니다. 예를 들어 사람 클래스에 나이 속성이 있다고 할 때, 나이는 무조건 0보다 크기 때문에 getter / setter를 설정하여 0 이하의 값이 들어오는 것을 방지할 수 있습니다.

이렇게 멤버에 직접적으로 접근하지 못하도록 하는 것을 캡슐화라고 합니다.

**readonly**읽기만 가능한 속성을 선언하기 위해 사용하며, 속성을 읽기 전용으로 설정해 변경할 수 없게 만듭니다. 그래서 선언될 때나 생성자에 값을 설정한 이후에는 수정이 불가능한 속성입니다.

변경될 경우가 없는 상수에 해당 키워드를 이용합니다. 비슷한 기능을 하는 **`const`**가 있는데 **`const`**는 변수 참조를 위한 것이고 **`readonly`**는 속성을 위한 것입니다.

**static**객체마다 할당되지 않고 클래스의 모든 객체가 공유하는 멤버인 전역 멤버를 선언할 때 사용합니다. 따라서 인스턴스 없이도 클래스 자체에서 해당 변수를 접근할 수 있습니다.

static은 멤버를 정적으로 선언하며 **`클래스명.`**을 이용해 접근이 가능합니다.

    
### 추상 클래스

추상 클래스는 다른 클래스들이 파생될 수 있는 기초 클래스로 직접 인스턴스화를 할 수 없는 클래스입니다.

**`abstract`** 키워드를 이용해 추상 클래스나 추상 메소드를 정의하며, 추상 메소드는 클래스에 구현되어 있지 않기 때문에 파생된 클래스에서 구현해야 합니다. 즉, 추상 클래스는 사용을 위해서는 상속을 강제하는 클래스입니다.

**템플릿 메소드 패턴(Template Method Pattern)**템플릿 메소드 패턴은 기능의 구조만 메소드에 정의하고, 하위 클래스에서 기능의 구조는 유지한 채 세부적인 알고리즘만 재정의 하는 디자인 패턴입니다.

전체적인 구조가 동일하고, 상황에 따라 알고리즘을 확장 및 변경하기 때문에 코드 중복을 최소화할 수 있는 이점이 있습니다.

추상 클래스를 이용해 상위 클래스에서 메소드의 구조를 잡고, 하위 클래스에서 디테일한 알고리즘을 변경함으로써 템플릿 메소드 패턴을 적용할 수 있습니다.

> 디자인 패턴이란 소프트웨어 설계에서 공통적으로 자주 발생하는 문제들을 해결하기 위한 설계 방법을 정리한 패턴을 말합니다. 즉, 문제가 발생하지 않는 코드 작성을 위한 정형화된 방법입니다.


## **Generic**

### **1. Generic이란?**

앞서 유틸리티 타입을 다룰 때 잠깐 살펴보았던 제네릭을 자세히 다뤄봅시다. 제네릭(Generic)이란 어떤 함수나 클래스가 사용할 타입을 생성 단계가 아닌 사용 단계에서 정의하는 프로그래밍 기법입니다. 즉, 타입을 명시할 때 선언 시점이 아닌 생성 시점에 명시하여 하나의 타입으로만 사용하지 않고 다양한 타입을 사용할 수 있습니다. 일반적인 정적 타입 언어는 함수나 클래스를 정의할 때 타입을 선언해야 하지만, 제네릭을 이용해 코드가 수행될 때 타입이 명시되도록 하는 것입니다.

예를 들어 문자를 그대로 반환하는 함수에 아래와 같이 제네릭을 적용할 수 있습니다.

```
function echo<T>(text: T): T {
  return text;
}
console.log(echo<string>("hi"));
console.log(echo<number>(10));
console.log(echo<boolean>(true));

```

여기서 식별자 T는 Type의 약자로, 추가될 때마다 U, V, … 순으로 추가하는 것이 일반적입니다. 하지만 어떤 식별자도 상관이 없어, 필드 이름의 첫 글자를 사용하기도 합니다.

**제네릭을 사용하는 이유**

- 제네릭을 사용하면 재사용성이 높은 함수나 클래스를 생성할 수 있습니다. 위의 **`echo`** 함수에서 제네릭을 사용하지 못했다면 타입별로 하나의 함수를 만들어야 할 것입니다. 제네릭을 사용하면 하나만 선언해도 여러 타입에서 동작이 가능합니다.
- 제네릭을 사용하면 중복되는 코드가 줄어들고 반환되는 타입을 명시하기 때문에 코드의 가독성이 좋아집니다.
- 만약 제네릭이 없다면 아래와 같이 **`any`** 타입을 이용해야 합니다.
    
    ```
    function echo2(text: any): any {
        return text;
    }
    
    ```
    
    - 하지만 **`any`** 타입은 컴파일 시 타입을 체크하지 않기 때문에 입력된 타입에 대한 메소드의 힌트를 사용할 수 없고, 컴파일 시 발견되는 에러를 발견할 수 없게됩니다.

### 2. Generic으로 함수와 클래스 만들기

- **제네릭을 이용한 함수 생성**앞서 살펴보았듯 꺽쇠(**`<>`**)와 식별자를 입력해 제네릭을 만들 수 있습니다. 다른 예시로 배열을 입력 받아 정렬 후 반환하는 제네릭을 만든다면, 아래와 같이 만들고 사용할 수 있습니다.

```
function sort<T>(items: T[]): T[] {
  return items.sort();
}
const nums: number[] = [1, 2, 3, 4];
const chars: string[] = ["a", "b", "c", "d"];
sort<number>(nums);
sort<string>(chars);

```

- **제네릭을 사용한 클래스 생성**클래스에서는 제네릭을 어떻게 사용하는지 간단한 큐를 구현해보며 살펴보겠습니다. 마찬가지로 클래스 옆에 **`<T>`**를 작성하며, 필드나 메소드에 해당 식별자를 타입으로 명시해주면 됩니다.**`pop()`** 메소드에 있는 **`|`**는 유니온 타입을 사용하기 위한 연산자입니다. 유니온 타입은 명시된 타입 중 하나가 올 수 있다는 것을 나타냅니다. 여기서는 T 타입이 반환되거나, 배열이 빈 경우 undefined가 반환되기 때문에 두 가지를 명시하였습니다.

```
class Queue<T> {

  protected data: Array<T> = [];

  push(item: T) {
    this.data.push(item);
  }

  pop(): T | undefined {
    return this.data.shift();
  }
}

```
### 3. Union type

유니온(Union) 타입은 어떤 타입이 올 지 경우의 수를 고려하여 타입을 명시하는 것으로 **`|`**를 이용해 선언합니다. 제네릭과 마찬가지로 유니온 타입을 이용하여 여러 가지 타입을 다룰 수 있습니다.

하지만 유니온 타입의 리턴 값은 사용된 하나의 타입이 아니라 선언된 전체 유니온 타입으로 지정이 되며, 유니온 타입에서 선언한 타입들의 공통된 메소드만 사용할 수 있습니다. 예를 들어, **`printMessage`**의 경우, string과 number를 포함한 유니온 타입이기 때문에 string에서만 사용 가능한 **`length`** 메소드를 사용할 수 없습니다.

```
const printMessage = (message: string | number) => {
  return message;
}
const message1 = printMessage(1234);
const message2 = printMessage("hello world!");

message2.length;

```



### 4. 제약조건 (Constraints / keyof)

제네릭에서 원하지 않는 속성에 접근하는 것을 막기 위해 **`extends`** 키워드를 이용해 제약조건(Constraints)을 사용할 수 있습니다. 아래의 경우 **`printMessage`**의 제네릭 타입으로 string, number 외의 타입이 오는 경우 에러가 발생하게 됩니다.

```
const printMessage = <T extends string | number>(message: T): T => {
  return message;
}

```

**ketof`ketof`**를 이용하면 객체의 키에 제약 조건을 걸 수 있습니다. 아래의 경우 U 타입에 들어오는 값이 T 타입의 키에 포함되어 있지 않다면 에러가 발생하게 됩니다.

```
const getProperty = <T extends object, U extends keyof T>(obj: T, key: U) => {
  return obj[key]
}

```



### 5. 디자인 패턴 (Factory Pattern with Generics)

팩토리 패턴(Factory Pattern)이란 객체를 생성하는 인터페이스만 미리 정의하고, 인스턴스를 만드는 것을 서브 클래스가 하는 패턴입니다. 여러 개의 서브 클래스를 가진 슈퍼 클래스가 있을 때, 입력에 따라 하나의 서브 클래스의 인스턴스를 반환합니다.

예를 들어 **`Car`** 인터페이스를 **`implements`**하는 **`Bus`** 클래스와 **`Taxi`** 클래스가 있다고 가정합니다. 만약 인스턴스를 생성하는 **`CarFactory`** 클래스가 있다고 할 때, 아래처럼 작성하는 경우 타입이 추가될 때마다 **`getInstance`** 메소드에서 직접 코드를 추가해야 합니다.

```
class CarFactory {
  static getInstance(type: String): Car {
    switch (type) {
      case "bus":
        return new Bus();
      default:
        return new Taxi();
    }
  }
}

```

하지만 제너릭을 이용해 **`getInstance`** 메소드가 여러 서브 클래스를 타입으로 가질 수 있게, 즉 타입을 반환만 할 수 있게 만들고 타입을 넘겨주도록 작성한다면 새로운 타입이 추가되어도 **`getInstance`**를 수정할 필요가 없게 됩니다.

```
class CarFactory {
  static getInstance<T extends Car>(type: { new (): T }): T {
    return new type();
  }
}
```
## **Interface**

### 1. Interface란?

인터페이스(Interface)란 코드 내 계약(약속, 규칙)을 정의하는 강력한 방법입니다. 인터페이스는 일반적으로 변수, 함수, 클래스의 타입을 체크하기 위해 사용됩니다. 예를 들면 아래 **`elice`** 변수는 **`Person`** 인터페이스의 계약을 준수해야만 합니다.

```
interface Person {
  name: string,
  age: number
}

let elice: Person = {name: "rabbit", age: 13};

```

앞서 살펴보았던 타입을 정의하는 type alias에 대해 기억하시나요?

```
type Human = {
  name: string;
  age: number;
};

```

type alias는 인터페이스와 비슷한 역할을 하지만, type alias는 확장(**`extends`**)가 불가능하고 인터페이스는 확장이 가능합니다. 따라서 웬만하면 인터페이스를 사용하는 것이 좋습니다. 인터페이스의 확장에 대해서는 뒤에서 학습할 예정입니다.

인터페이스는 객체나 함수의 스펙, 배열의 접근 방식, 클래스 같은 범주에 대해 계약을 정의할 수 있습니다. 예를 들어 아래와 같은 인터페이스가 있다고 가정할 때 각각의 인터페이스 사용 예시를 살펴보세요.



```
interface Person {
    name: string
}

```

- 변수
    
    ```
    let elice: Person = {name: "rabbit"};
    
    ```
    
- 함수
    
    ```
    function greeting(person: Person): void {
        console.log(`Hello ${person.name}`);
    }
    
    ```
    
- 클래스
    
    ```
    class Member implements Person {
        constructor (
            public name: string
        ) { }
    }
    
    ```
    
- 배열의 경우 아래와 같이 인터페이스를 이용할 수 있습니다.
    
    ```
    interface Person {
        [index: number]: string;
    }
    let people: Person = ["rabbit", "cheshire", "queen"];
    
    ```
    > 추상 클래스 vs 인터페이스추상 클래스는 일반 클래스와 달리 추상 메소드가 포함된 클래스로 일반 메소드를 포함할 수 있습니다. 반면 인터페이스는 모든 메소드가 추상 메소드여야 하는 차이가 있습니다.추상 클래스는 상속을 통해 추상 메소드의 구현을 강제하여 자식 클래스에서 일부 동작을 구현하도록 만든 것입니다. 인터페이스는 모든 구현에 대한 계약을 작성해둔 것입니다. 추상 클래스는 프로그램의 전체 구조를 잡기 위해 사용하고, 인터페이스는 기본적인 설계도로써 개발 협업에서 사용하기 용이합니다.
>
