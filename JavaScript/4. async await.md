출처 : 엘리스 SW엔지니어 트랙
# 1. async / await 배우기

## try / catch 문법

```jsx
try {
	JSON.parse("test");
	// throw "Error!";
} catch (e){
	console.log("Error :" + e);
} finally {
	console.log("Always call");
}
```

- 예외 처리를 위한 문법
- try 블럭 내에서 에러가 발생하면 catch 블럭에서 처리할 수 있다
- throw를 통해서 일부러 에러를 발생 시킬 수 있다
```jsx
try {
  JSON.parse("test");
  throw "Error!";
} catch (e) {
  console.log("Error: " + e); //문법에러
} finally {
  console.log("Always call"); //에러 나도 동작
}

try {
  JSON.parse("test");
  console.log(a);
  let a;
  let b = 1;
  b.toUpperCase();
  throw new TypeError("type error!");
} catch (e) {
  if (e instanceof ReferenceError) {
    console.log("ReferenceError");
  } else if (e instanceof SyntaxError) {
    console.log("SyntaxError"); //문법에러
  } else if (e instanceof TypeError) {
    console.log("TypeError");
  }
  console.log("Error: " + e);
}
```
## async function

- 비동기 함수임을 선언하는 함수
- 함수를 실행하면 Promise객체를 반환함
- 명시적으로 Promise객체를 반환해도 동일함

```jsx
async function f(){
	return 1;
}
async function f(){
	return Promise.resolve(1);
}
```

- 두 함수는 똑같은 결과를 반환함
- Promise가 아닌 값을 반환하더라도 무조건 Promise로 감싸서 반환됨

```jsx
function sleep(ms) {
  const start = Date.now();
  while (Date.now() - start < ms);
}

function getData() {
  return new Promise((resolve, reject) => {
    try {
      sleep(1000);
      const userInfo = {
        user: {
          id: "elice",
          password: "1234",
        },
        createDate: "2022-04-30",
      };
      resolve(userInfo);
    } catch (err) {
      reject(err);
    }
  });
}

function parseValue(data) {
  return new Promise((resolve, reject) => {
    try {
      resolve(data.user);
    } catch (err) {
      reject(err);
    }
  });
}

function auth(user) {
  return new Promise((resolve, reject) => {
    if (user.id == "elice" && user.password == "1234") {
      resolve("ok");
    } else {
      resolve("ID 혹은 비밀번호가 틀립니다.");
    }
  });
}

function display(result) {
  return new Promise((resolve, reject) => {
    if (result == "ok") {
      console.log("로그인 성공");
    } else {
      console.log(result);
    }
    resolve();
  });
}

/* 
//바꾸기전
getData() //1. 데이터를 가공. 프로미스를 반환하고 2번 감
  .then(parseValue) //2.에서 프로미스를 반환하고 3번 감
  .then(auth) //3.에서 프로미스를 반환하고 4번 감
  .then(display) //4.에서 프로미스를 반환하고, 에러 찾고 끝
  .catch((err) => console.log(err));

*/

//async써주면 프로미스가 됨
async function run() {
  //1. 함수로 만들고 async 붙여줌
  try {
    //try로 에러 날시 catch로 연결하기 위함
    const step1 = await getData(); //2. 데이터 받아옴
    const step2 = await parseValue(step1); //3. 데이터를 가공함
    const step3 = await auth(step2); //4. 유저 검증하고 반환
    const step4 = await display(step3); //5.view해주고 반환
  } catch (err) {
    console.log(err);
  }
}
run(); //함수호출
```
## async / await

```jsx
let ex1 = new Promise((resolve, reject) => {
	setTimeout(() => resolve("Call!"), 1000); 
});

async function f() {
	let result = await ex1();
	console.log(result);
}
```

- await async 함수 내에서만 사용 가능
- promise가 완료될 때까지 다음 코드를 실행하지 않고 기다림

```jsx
// 이전 방식의 Promise .then 형식
let waitSeconds = function () {
  return new Promise((resolve) => {
    setTimeout(function () {
      resolve(10);
      console.log("Call here2");
    }, 1000);
  });
};

waitSeconds().then((res) => console.log(res));
console.log("Call here1");
// Call here1 <- 바로 동작
// Call here2 <- 1초후
// 10 <- 1초후 here2와 같이

//===========================================================================
// async / await 로 변경한 방식
let waitSeconds = function () {
  return new Promise((resolve) => {
    setTimeout(function () {
      resolve(10);
      console.log("Call here2");
    }, 1000);
  });
};
//아래부터 바뀜, 함수로 감싸고 시작함
async function hello() {
  const res = await waitSeconds(); //await때문에 콘솔 res가 먼저 나오지 않음
  console.log(res);
}

hello();
console.log("Call here1");
// Call here1 <- 바로 동작
// Call here2 <- 1초후
// 10 <- 1초후 here2와 같이
```
# 2. HTTP 알아보기

- html 같은 하이퍼미디어 문서를 전송하기 프로토콜
- 프로토콜 : 데이터의 교환방식을 정의하는 규칙의 집합
- HyperText Transfer Protocol
- 웹에서 이뤄지는 모든 데이터 교환의 기초
- 서버와 통신하는 것을 의미함

## HTTP Request

- 브라우저 → http request(url + 요청메소드) → 서버

![Untitled](https://user-images.githubusercontent.com/83447120/180339099-2b1dfbee-e108-47e7-814d-2ac1f0fb89e7.png)
- Version of the protocol : http 통신 버젼
- Status code : 요청에 대한 응답의 상태코드
- Status message : 확인상태
- Headers : 요청에 대한 추가 정보를 전달
![Untitled](https://user-images.githubusercontent.com/83447120/180339157-f1b03a89-2d8c-4e5a-9844-b7de669c417d.png)
# 3. Fetch API 더 알아보기

```jsx
async function insertPost (reqUrl, data) {
	const res = await fetch(reqUrl, {
	//메서드 바디 헤더 순서는 중요하지 않음. 객체이기 때문이고, 배열이었으면 중요함
		method : "POST", // 추가
		headers : {
			"Content-Type" : "application/json",
		},
		redirect : "follow",
		body : JSON.stringify(data),
	});
	return res.json();
}
insertPost("https://jsonplaceholder.typicode.com/posts", {answer : 42});
```

```jsx
//삭제
async function deletePost(reqUrl, postId) {
  try {
    if (postId < 0) throw new Error("wrong postId"); //postId가 음수일때 

    const res = await fetch(reqUrl + `/${postId}`, {
      method: "DELETE", //삭제코드
    });
    return res.json();
  } catch (e) {
    return Promise.reject(e);
  }
}

const result = deletePost("https://jsonplaceholder.typicode.com/posts", -10)
  .then((data) => console.log(data)) //{} 빈 객첼를 응답해줌
  .catch((err) => console.error(err));
```

- delete에서도 예외처리해줘야함

```jsx
//수정
async function updatePost(reqUrl, postId, data) {
  try {
    if (postId < 0) throw new Error("wrong postId");

    const res = await fetch(reqUrl + `/${postId}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json; charset=UTF-8",
      },
      body: JSON.stringify(data),
    });
    return res.json();
  } catch (e) {
    return Promise.reject(e);
  }
}

const result = updatePost("https://jsonplaceholder.typicode.com/posts", 10, {
  title: "example",
  body: "Hello, world!",
}) //추가할 객체 적어줌
  .then((data) => console.log(data))
  .catch((err) => console.error(err));
```
